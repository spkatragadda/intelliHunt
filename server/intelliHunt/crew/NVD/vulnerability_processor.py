"""
Vulnerability Processor for Crew Workflow Integration
This module processes recent CVE data and formats it for the research agent.
"""

import json
import logging
from datetime import datetime, timedelta
from typing import Dict, List, Any, Optional
from pathlib import Path
from NVD.cve_fetcher import CVEFetcher
from NVD.cpe_data_processor import CPEDataProcessor

# Configure logging to write to logs.txt file
def setup_logging():
    """Setup logging to write to logs.txt file in the same format as crew logs."""
    logger = logging.getLogger(__name__)
    logger.setLevel(logging.INFO)
    
    # Remove any existing handlers
    for handler in logger.handlers[:]:
        logger.removeHandler(handler)
    
    # Create file handler for logs.txt
    log_file = Path(__file__).parent / "logs.txt"
    file_handler = logging.FileHandler(log_file, mode='a')
    file_handler.setLevel(logging.INFO)
    
    # Create formatter that matches crew log format
    formatter = logging.Formatter('%(asctime)s: %(message)s', datefmt='%Y-%m-%d %H:%M:%S')
    file_handler.setFormatter(formatter)
    
    # Add handler to logger
    logger.addHandler(file_handler)
    
    return logger

logger = setup_logging()

class VulnerabilityProcessor:
    """
    Processes recent vulnerability data for crew workflow integration.
    Combines CPE data with recent CVE information for threat intelligence analysis.
    """
    
    def __init__(self, cpe_data_path: str = None, days_back: int = 7):
        """
        Initialize the vulnerability processor.
        
        Args:
            cpe_data_path: Path to the CPE data file
            days_back: Number of days to look back for CVEs
        """
        self.cpe_data_path = cpe_data_path
        self.days_back = days_back
        self.cve_fetcher = CVEFetcher()
        self.cpe_processor = None
        
        if cpe_data_path:
            self.cpe_processor = CPEDataProcessor(cpe_data_path)
    
    def load_latest_cpe_data(self) -> str:
        """
        Load the most recent CPE data file.
        
        Returns:
            Path to the CPE data file
        """
        crew_dir = Path(__file__).parent
        cpe_files = list(crew_dir.glob("cpe_data_*.json"))
        
        if not cpe_files:
            raise FileNotFoundError("No CPE data files found. Please run the NVD CPE client first.")
        
        # Use the most recent file
        latest_file = max(cpe_files, key=lambda x: x.stat().st_mtime)
        self.cpe_data_path = str(latest_file)
        self.cpe_processor = CPEDataProcessor(self.cpe_data_path)
        
        logger.info(f"Loaded CPE data from: {self.cpe_data_path}")
        return self.cpe_data_path
    
    def fetch_recent_vulnerabilities(self) -> Dict[str, Any]:
        """
        Fetch recent vulnerabilities for the organization's CPEs.
        
        Returns:
            Dictionary containing vulnerability data
        """
        if not self.cpe_data_path:
            self.load_latest_cpe_data()
        
        logger.info(f"Fetching vulnerabilities from the past {self.days_back} days")
        vulnerability_data = self.cve_fetcher.fetch_recent_vulnerabilities(
            self.cpe_data_path, 
            self.days_back
        )
        # here
        return vulnerability_data
    
    def generate_crew_input_with_vulnerabilities(self) -> Dict[str, Any]:
        """
        Generate crew workflow input that includes recent vulnerability data.
        
        Returns:
            Dictionary containing crew workflow input with vulnerability focus
        """
        if not self.cpe_processor:
            self.load_latest_cpe_data()
        
        # Get base crew input from CPE processor
        base_crew_input = self.cpe_processor.generate_crew_input()
        
        # Fetch recent vulnerabilities
        vulnerability_data = self.fetch_recent_vulnerabilities()
        
        # Generate research agent input from vulnerabilities
        research_input = self.cve_fetcher.generate_research_agent_input(vulnerability_data)
        
        # Combine base input with vulnerability data
        enhanced_crew_input = {
            **base_crew_input,
            'vulnerability_data': {
                'recent_cves': research_input['cve_list'],
                'high_priority_cves': research_input['high_priority_cves'],
                'total_cves_found': research_input['total_cves'],
                'time_period': research_input['time_period'],
                'cve_details': research_input['cve_details']
            },
            'research_focus': 'Recent Vulnerability Analysis',
            'threat_intelligence_priority': 'High',
            'analysis_timeframe': f"Last {self.days_back} days"
        }
        
        # Update URL list to include CVE-specific sources
        enhanced_crew_input['url_list'].extend([
            "https://cve.mitre.org/cve/search_cve_list.html",
            "https://www.cvedetails.com/",
            "https://nvd.nist.gov/vuln/search"
        ])
        
        return enhanced_crew_input
    
    def save_enhanced_crew_input(self, output_path: str = None) -> str:
        """
        Save enhanced crew workflow input with vulnerability data.
        
        Args:
            output_path: Optional custom output path
            
        Returns:
            Path to the saved file
        """
        enhanced_input = self.generate_crew_input_with_vulnerabilities()
        
        if output_path is None:
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            output_path = Path(__file__).parent / f"enhanced_crew_input_{timestamp}.json"
        
        with open(output_path, 'w') as f:
            json.dump(enhanced_input, f, indent=2)
        
        logger.info(f"Enhanced crew input saved to: {output_path}")
        return str(output_path)
    
    def get_vulnerability_summary(self) -> str:
        """
        Generate a summary of recent vulnerabilities for the organization.
        
        Returns:
            Formatted summary report string
        """
        if not self.cpe_processor:
            self.load_latest_cpe_data()
        
        vulnerability_data = self.fetch_recent_vulnerabilities()
        research_input = self.cve_fetcher.generate_research_agent_input(vulnerability_data)
        
        # Count vulnerabilities by severity
        severity_counts = {}
        for cve in research_input['cve_details']:
            severity = cve['severity']
            severity_counts[severity] = severity_counts.get(severity, 0) + 1
        
        # Get top affected CPEs
        cpe_vulnerability_counts = {}
        for cpe_name, cves in vulnerability_data['cpe_vulnerabilities'].items():
            if cves:
                cpe_vulnerability_counts[cpe_name] = len(cves)
        
        top_affected_cpes = sorted(cpe_vulnerability_counts.items(), 
                                 key=lambda x: x[1], reverse=True)[:10]
        
        summary = f"""
# Recent Vulnerability Analysis Summary

## Time Period
- **Analysis Period**: Last {self.days_back} days
- **Collection Timestamp**: {vulnerability_data['collection_timestamp']}
- **Organization**: {vulnerability_data.get('organization', {}).get('name', 'Unknown')}

## Vulnerability Statistics
- **Total CVEs Found**: {research_input['total_cves']}
- **Unique CVEs**: {research_input['unique_cves']}
- **High Priority CVEs**: {len(research_input['high_priority_cves'])}

## Severity Breakdown
"""
        
        for severity, count in sorted(severity_counts.items(), 
                                   key=lambda x: ['CRITICAL', 'HIGH', 'MEDIUM', 'LOW', 'UNKNOWN'].index(x[0]) 
                                   if x[0] in ['CRITICAL', 'HIGH', 'MEDIUM', 'LOW', 'UNKNOWN'] else 999):
            summary += f"- **{severity}**: {count} CVEs\n"
        
        summary += f"""
## Top Affected CPEs
"""
        
        for cpe_name, count in top_affected_cpes:
            summary += f"- **{cpe_name}**: {count} CVEs\n"
        
        summary += f"""
## High Priority CVEs (CRITICAL/HIGH Severity)
"""
        
        for cve in research_input['high_priority_cves'][:10]:  # Show top 10
            summary += f"""
### {cve['cve_id']}
- **Severity**: {cve['severity']}
- **CVSS Score**: {cve['cvss_score']}
- **Published**: {cve['published']}
- **CPE**: {cve['cpe_name']}
- **Description**: {cve['description'][:200]}...
"""
        
        return summary
    
    def save_vulnerability_summary(self, output_path: str = None) -> str:
        """
        Save vulnerability summary to file.
        
        Args:
            output_path: Optional custom output path
            
        Returns:
            Path to the saved file
        """
        summary = self.get_vulnerability_summary()
        
        if output_path is None:
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            output_path = Path(__file__).parent / f"vulnerability_summary_{timestamp}.md"
        
        with open(output_path, 'w') as f:
            f.write(summary)
        
        logger.info(f"Vulnerability summary saved to: {output_path}")
        return str(output_path)

def main():
    """Main function for testing the vulnerability processor."""
    try:
        # Initialize vulnerability processor
        processor = VulnerabilityProcessor(days_back=7)
        
        # Generate enhanced crew input
        enhanced_input_path = processor.save_enhanced_crew_input()
        
        # Generate and save vulnerability summary
        summary_path = processor.save_vulnerability_summary()
        
        # Load and display summary
        enhanced_input = processor.generate_crew_input_with_vulnerabilities()
        
        print("Vulnerability Processing Complete!")
        print(f"Enhanced crew input saved to: {enhanced_input_path}")
        print(f"Vulnerability summary saved to: {summary_path}")
        print(f"\nSummary:")
        print(f"- Total CVEs found: {enhanced_input['vulnerability_data']['total_cves_found']}")
        print(f"- High priority CVEs: {len(enhanced_input['vulnerability_data']['high_priority_cves'])}")
        print(f"- Analysis timeframe: {enhanced_input['analysis_timeframe']}")
        
    except Exception as e:
        logger.error(f"Error in main execution: {e}")
        raise

if __name__ == "__main__":
    main()
